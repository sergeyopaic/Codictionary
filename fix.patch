diff --git a/lib/main.dart b/lib/main.dart
index ae8c4f9fe5928d26b4543c7ede1e40ab8e61c33b..6559d71a4c1ee107754c1f6874fbb127aa57f6fe 100644
--- a/lib/main.dart
+++ b/lib/main.dart
@@ -1,297 +1,146 @@
-import 'dart:convert';
-import 'dart:io';
 import 'dart:async';
 import 'package:flutter/material.dart';
-import 'package:http/http.dart' as http;
-import 'package:path_provider/path_provider.dart';
-import 'package:flutter/services.dart' show rootBundle;
 import 'package:flutter_dotenv/flutter_dotenv.dart';
 import 'package:uuid/uuid.dart';
 
 import 'models/word.dart';
-import 'services/storage_service.dart';
 import 'services/gpt_service.dart';
+import 'services/storage_service.dart';
 import 'services/translate_service.dart';
 
-final apiKey = dotenv.env['OPENAI_API_KEY'];
-final deeplApiKey = dotenv.env['DEEPL_API_KEY'];
-
-const String TRANSLATE_URL = "https://api-free.deepl.com/v2/translate";
-const String GPT5_MINI_URL = "https://api.openai.com/v1/responses";
-Future<String> askGPT5Mini(String prompt) async {
-  final resp = await http.post(
-    Uri.parse(GPT5_MINI_URL), // https://api.openai.com/v1/responses
-    headers: {
-      "Content-Type": "application/json",
-      "Authorization": "Bearer $apiKey",
-    },
-    body: jsonEncode({
-      "model": "gpt-4.1-mini", // не "gpt-5-mini"
-      "input": prompt,
-      "temperature": 1,
-      "max_output_tokens": 400, // можно 200–500
-    }),
-  );
-
-  if (resp.statusCode != 200) {
-    throw Exception("OpenAI API error: ${resp.statusCode} ${resp.body}");
-  }
-
-  final data = jsonDecode(resp.body);
-
-  // Response API: data['output'] — список сообщений, каждое содержит content[]
-  final output = data['output'] as List<dynamic>? ?? const [];
-  if (output.isEmpty) return "No output from model.";
+late String? apiKey;
+late String? deeplApiKey;
 
-  final first =
-      output.first as Map<String, dynamic>?; // {id, type, role, content, ...}
-  final content = first?['content'] as List<dynamic>? ?? const [];
-
-  // Ищем text-часть (обычно type == 'output_text')
-  String? text;
-  for (final part in content) {
-    final p = part as Map<String, dynamic>;
-    if (p['text'] is String) {
-      text = p['text'] as String;
-      break;
-    }
-  }
-
-  return text ?? "No text in response.";
-}
+late final GptService gpt;
+late final TranslateService translate;
+late final StorageService storage;
 
 Future<void> showGPTTestDialog(BuildContext context) async {
   final TextEditingController promptController = TextEditingController();
   String gptAnswer = "Waiting for response...";
 
   await showDialog(
     context: context,
     builder: (context) {
       return StatefulBuilder(
         builder: (context, setState) {
           Future<void> sendPrompt() async {
             final prompt = promptController.text.trim();
             if (prompt.isEmpty) return;
 
             setState(() => gptAnswer = "Loading...");
 
             try {
-              final resp = await http.post(
-                Uri.parse("https://api.openai.com/v1/responses"),
-                headers: {
-                  "Content-Type": "application/json",
-                  "Authorization": "Bearer $apiKey",
-                },
-                body: jsonEncode({
-                  "model": "gpt-4.1-mini",
-                  "input": prompt,
-                  "temperature": 1,
-                  "max_output_tokens": 500,
-                }),
-              );
-
-              if (resp.statusCode == 200) {
-                final data = jsonDecode(resp.body);
-                final output = data['output'] as List<dynamic>? ?? [];
-                final firstMessage = output.isNotEmpty ? output[0] : null;
-                final text = firstMessage != null
-                    ? (firstMessage['content'] as List<dynamic>)[0]['text']
-                          as String
-                    : "No content";
-
-                setState(() => gptAnswer = text);
-              } else {
-                setState(
-                  () => gptAnswer = "Error: ${resp.statusCode} ${resp.body}",
-                );
-              }
+              final text = await gpt.sendPrompt(prompt);
+              setState(() => gptAnswer = text);
             } catch (e) {
               setState(() => gptAnswer = "Exception: $e");
             }
           }
 
           return AlertDialog(
             title: const Text("GPT Test"),
             content: SizedBox(
               width: double.maxFinite,
               child: Column(
                 mainAxisSize: MainAxisSize.min,
                 children: [
                   TextField(
                     controller: promptController,
                     decoration: const InputDecoration(
                       labelText: "Enter prompt",
                     ),
                   ),
                   const SizedBox(height: 12),
                   Text(gptAnswer, style: const TextStyle(fontSize: 14)),
                 ],
               ),
             ),
             actions: [
               TextButton(
                 onPressed: () => Navigator.pop(context),
                 child: const Text("Close"),
               ),
               ElevatedButton(onPressed: sendPrompt, child: const Text("Send")),
             ],
           );
         },
       );
     },
   );
 }
 
-// ====== Утилиты ======
-Future<File> _getDictFile() async {
-  final dir = await getApplicationDocumentsDirectory();
-  final file = File('${dir.path}/dictionary.json');
-  // Для отладки полезно напечатать путь
-  debugPrint('Dictionary file path: ${file.path}');
-  return file;
-}
-
-const List<Map<String, String>> _defaultWords = [
-  {"eng": "apple", "rus": "яблоко"},
-  {"eng": "dog", "rus": "собака"},
-  {"eng": "house", "rus": "дом"},
+// ====== Данные по умолчанию ======
+const List<Word> _defaultWords = [
+  Word(id: '1', eng: 'apple', rus: 'яблоко'),
+  Word(id: '2', eng: 'dog', rus: 'собака'),
+  Word(id: '3', eng: 'house', rus: 'дом'),
 ];
 
-Future<List<Map<String, String>>> loadDict() async {
-  try {
-    final file = await _getDictFile();
-    if (await file.exists()) {
-      final text = await file.readAsString();
-      if (text.trim().isEmpty) {
-        debugPrint('Dict file empty -> returning default');
-        await saveDict(_defaultWords); // перезапишем дефолтом
-        return List.from(_defaultWords);
-      }
-      final raw = jsonDecode(text);
-      if (raw is List) {
-        // конвертация каждого элемента в Map<String,String>
-        final list = raw.map<Map<String, String>>((e) {
-          if (e is Map) return Map<String, String>.from(e);
-          return <String, String>{};
-        }).toList();
-        return list;
-      }
-      debugPrint('Dict file JSON not a list -> using default');
-    } else {
-      // Файла нет — попробуем взять bundled asset (если он есть)
-      try {
-        final asset = await rootBundle.loadString('assets/dictionary.json');
-        final raw = jsonDecode(asset);
-        final list = (raw as List)
-            .map<Map<String, String>>((e) => Map<String, String>.from(e))
-            .toList();
-        // Сохраним копию в documents, чтобы далее использовать её
-        await saveDict(list);
-        debugPrint('Copied initial dictionary from assets into documents');
-        return list;
-      } catch (e) {
-        debugPrint('No asset dictionary or failed to load it: $e');
-        // создадим файл с дефолтом
-        await saveDict(_defaultWords);
-        return List.from(_defaultWords);
-      }
-    }
-  } catch (e, st) {
-    debugPrint('loadDict error: $e\n$st');
-  }
-  // fallback
-  return List.from(_defaultWords);
-}
-
-Future<void> saveDict(List<Map<String, String>> dict) async {
-  try {
-    final file = await _getDictFile();
-    final text = jsonEncode(dict);
-    await file.writeAsString(text);
-    debugPrint('Saved dictionary (${dict.length} entries) to ${file.path}');
-  } catch (e, st) {
-    debugPrint('saveDict error: $e\n$st');
-  }
-}
-
-Future<String> translateWord(String word) async {
-  final resp = await http.post(
-    Uri.parse(TRANSLATE_URL),
-    headers: {"Content-Type": "application/x-www-form-urlencoded"},
-    body: "auth_key=$deeplApiKey&text=$word&target_lang=RU",
-  );
-
-  if (resp.statusCode != 200) {
-    throw Exception("Translation failed: ${resp.body}");
-  }
-
-  final data = jsonDecode(resp.body);
-  return data["translations"][0]["text"];
-}
-
 // ====== Приложение ======
 Future<void> main() async {
   // обязательно нужно вызвать, чтобы инициализировать биндинги Flutter
   WidgetsFlutterBinding.ensureInitialized();
 
   // загружаем переменные из .env
   await dotenv.load(fileName: ".env");
+  apiKey = dotenv.env['OPENAI_API_KEY'];
+  deeplApiKey = dotenv.env['DEEPL_API_KEY'];
+  storage = StorageService();
+  gpt = GptService(apiKey ?? '');
+  translate = TranslateService(deeplApiKey ?? '');
 
   runApp(const MyApp());
 }
 
 void showAddedWordPopup(BuildContext context) {
   final overlay = Overlay.of(context);
   final entry = OverlayEntry(
     builder: (context) =>
         Positioned(right: 16, bottom: 80, child: _AnimatedPopup()),
   );
 
   overlay.insert(entry);
   Future.delayed(const Duration(seconds: 2), () {
     entry.remove();
   });
 }
 
 class _AnimatedPopup extends StatefulWidget {
   @override
   State<_AnimatedPopup> createState() => _AnimatedPopupState();
 }
 
 class _AnimatedPopupState extends State<_AnimatedPopup>
     with SingleTickerProviderStateMixin {
   late AnimationController _controller;
   late Animation<double> _fade;
 
   @override
   void initState() {
     super.initState();
-    storage = StorageService();
-    gpt = GptService(apiKey ?? '');
-    translate = TranslateService(deeplApiKey ?? '');
-    _init();
     _controller = AnimationController(
       vsync: this,
       duration: const Duration(milliseconds: 400),
     )..forward();
 
     _fade = CurvedAnimation(parent: _controller, curve: Curves.easeInOut);
   }
 
   @override
   Widget build(BuildContext context) {
     return FadeTransition(
       opacity: _fade,
       child: Stack(
         alignment: Alignment.center,
         clipBehavior: Clip.none, // чтобы gif мог вылезать за пределы
         children: [
           // Сначала карточка
           Card(
             color: Colors.green.shade300,
             shape: RoundedRectangleBorder(
               borderRadius: BorderRadius.circular(16),
             ),
             child: Padding(
               padding: const EdgeInsets.all(12),
               child: Row(
diff --git a/lib/main.dart b/lib/main.dart
index ae8c4f9fe5928d26b4543c7ede1e40ab8e61c33b..6559d71a4c1ee107754c1f6874fbb127aa57f6fe 100644
--- a/lib/main.dart
+++ b/lib/main.dart
@@ -394,282 +243,278 @@ class CodeDictionaryTitle extends StatelessWidget {
               overflow: TextOverflow.fade,
               softWrap: false,
             ),
             // Заливка
             Text(
               text,
               style: base.copyWith(color: fillColor),
               maxLines: 1,
               overflow: TextOverflow.fade,
               softWrap: false,
             ),
           ],
         ),
       ],
     );
   }
 }
 
 class DictionaryScreen extends StatefulWidget {
   const DictionaryScreen({super.key});
   @override
   State<DictionaryScreen> createState() => _DictionaryScreenState();
 }
 
 class _DictionaryScreenState extends State<DictionaryScreen> {
-  List<Map<String, String>> words = [];
-  List<Map<String, String>> filteredWords = [];
+  List<Word> words = [];
+  List<Word> filteredWords = [];
   final TextEditingController searchController = TextEditingController();
   String searchQuery = "";
 
   @override
   void initState() {
     super.initState();
     _loadWords();
     searchController.addListener(_onSearchChanged);
   }
 
   @override
   void dispose() {
     searchController.dispose();
     super.dispose();
   }
 
   Future<void> _loadWords() async {
-    final dict = await loadDict();
+    final loaded = await storage.loadWords();
+    if (loaded.isEmpty) {
+      words = List<Word>.from(_defaultWords);
+      await storage.saveWords(words);
+    } else {
+      words = loaded;
+    }
     setState(() {
-      words = dict;
       filteredWords = List.from(words);
     });
   }
 
   void _onSearchChanged() {
     setState(() {
       searchQuery = searchController.text.trim().toLowerCase();
       _filterWords();
     });
   }
 
   void _filterWords() {
     if (searchQuery.isEmpty) {
       filteredWords = List.from(words);
     } else {
       filteredWords = words.where((word) {
-        final eng = word["eng"]?.toLowerCase() ?? "";
-        final rus = word["rus"]?.toLowerCase() ?? "";
+        final eng = word.eng.toLowerCase();
+        final rus = word.rus.toLowerCase();
         return eng.contains(searchQuery) || rus.contains(searchQuery);
       }).toList();
     }
   }
 
   Future<void> _showWordExplanation(BuildContext context, int index) async {
     if (index < 0 || index >= words.length) {
-      // на всякий случай, если indexOf вернул -1
-      ScaffoldMessenger.of(
-        context,
-      ).showSnackBar(const SnackBar(content: Text('Word not found.')));
+      ScaffoldMessenger.of(context)
+          .showSnackBar(const SnackBar(content: Text('Word not found.')));
       return;
     }
 
     String gptAnswer =
-        words[index]["desc"] ?? "Нет описания. Нажмите «Regenerate text».";
+        words[index].desc ?? "Нет описания. Нажмите «Regenerate text».";
 
     await showDialog(
       context: context,
       builder: (context) {
         return StatefulBuilder(
           builder: (context, setState) {
             Future<void> regenerate() async {
               setState(() => gptAnswer = "Loading...");
               try {
-                final eng = words[index]["eng"] ?? "";
-                final prompt =
-                    'Приведи пример использования слова "$eng" на английском языке. '
-                    'Дай русскоязычное описание длиной примерно 200 слов о том, как это слово переводится и где используется.';
-                final newText = await askGPT5Mini(prompt);
+                final eng = words[index].eng;
+                final newText = await gpt.explainWord(eng);
                 if (!context.mounted) return;
                 setState(() => gptAnswer = newText);
 
-                // обновляем и сохраняем
-                words[index]["desc"] = newText;
-                await saveDict(words);
+                words[index] = words[index].copyWith(desc: newText);
+                await storage.saveWords(words);
               } catch (e) {
                 if (!context.mounted) return;
                 setState(() => gptAnswer = "Ошибка: $e");
               }
             }
 
             return AlertDialog(
-              title: Text('Explanation for "${words[index]["eng"] ?? ""}"'),
+              title: Text('Explanation for "${words[index].eng}"'),
               content: SizedBox(
                 width: double.maxFinite,
                 child: Column(
                   mainAxisSize: MainAxisSize.min,
                   crossAxisAlignment: CrossAxisAlignment.start,
                   children: [
                     SingleChildScrollView(child: Text(gptAnswer)),
                     if (gptAnswer == "Loading...") ...[
                       const SizedBox(height: 12),
                       Row(
                         mainAxisSize: MainAxisSize.min,
                         children: const [
                           SizedBox(
                             width: 18,
                             height: 18,
                             child: CircularProgressIndicator(strokeWidth: 2),
                           ),
                           SizedBox(width: 8),
                           Text('Generating...'),
                         ],
                       ),
                     ],
                   ],
                 ),
               ),
               actions: [
                 TextButton(
                   onPressed: gptAnswer == "Loading..." ? null : regenerate,
                   child: const Text("Regenerate text"),
                 ),
                 TextButton(
                   onPressed: gptAnswer == "Loading..."
                       ? null
                       : () => Navigator.pop(context),
                   child: const Text("Close"),
                 ),
               ],
             );
           },
         );
       },
     );
   }
 
   Future<void> _addOrEditWord({int? index}) async {
     Timer? debounceTimer;
 
     final engController = TextEditingController(
-      text: index != null ? (words[index]["eng"] ?? '') : '',
+      text: index != null ? words[index].eng : '',
     );
     final rusController = TextEditingController(
-      text: index != null ? (words[index]["rus"] ?? '') : '',
+      text: index != null ? words[index].rus : '',
     );
 
     final engFocus = FocusNode();
     final rusFocus = FocusNode();
 
     bool autoTranslate = true;
     bool isSaving = false;
 
     // <-- объявляем заранее, чтобы замыкания могли ссылаться
     StateSetter? _setDialogState;
 
     Future<void> save() async {
       final eng = engController.text.trim();
       String rus = rusController.text.trim();
       if (eng.isEmpty) return;
 
       // автоперевод при пустом RUS
       if (autoTranslate && rus.isEmpty) {
         try {
-          rus = await translateWord(eng);
+          rus = await translate.translateToRu(eng);
         } catch (_) {
-          // оставляем как ввёл пользователь
           rus = rusController.text.trim();
         }
       }
 
       // показываем спиннер в диалоге
       _setDialogState?.call(() => isSaving = true);
 
       // генерируем описание ТОЛЬКО при добавлении
-      String? desc = index != null ? (words[index]["desc"]) : null;
+      String? desc = index != null ? words[index].desc : null;
       if (index == null) {
-        final prompt =
-            'Приведи пример использования слова "$eng" на английском языке. '
-            'Дай русскоязычное описание длиной примерно 200 слов о том, как это слово переводится и где используется.';
         try {
-          desc = await askGPT5Mini(prompt);
+          desc = await gpt.explainWord(eng);
         } catch (e) {
           desc = 'Ошибка при генерации описания: $e';
         }
       }
 
-      final newEntry = <String, String>{
-        "eng": eng,
-        "rus": rus,
-        if (desc != null) "desc": desc,
-      };
+      final newWord = Word(
+        id: index != null ? words[index].id : const Uuid().v4(),
+        eng: eng,
+        rus: rus,
+        desc: desc,
+      );
 
       if (!mounted) return;
 
       setState(() {
         if (index == null) {
-          words.add(newEntry);
+          words.add(newWord);
         } else {
-          words[index] =
-              newEntry; // desc оставляем как было, если редактирование
+          words[index] = newWord;
         }
         _filterWords();
       });
 
-      await saveDict(words);
+      await storage.saveWords(words);
 
       if (!mounted) return;
       Navigator.pop(context);
       showAddedWordPopup(context);
     }
 
     await showDialog(
       context: context,
       barrierDismissible: !isSaving,
       builder: (_) => StatefulBuilder(
         builder: (context, innerSetState) {
           // присваиваем ссылку, чтобы save() мог обновлять диалог
           _setDialogState = innerSetState;
 
           return AlertDialog(
             title: Text(index == null ? "Add Word" : "Edit Word"),
             content: Column(
               mainAxisSize: MainAxisSize.min,
               children: [
                 TextField(
                   controller: engController,
                   focusNode: engFocus,
                   autofocus: true,
                   textInputAction: TextInputAction.next,
                   decoration: const InputDecoration(labelText: "English"),
                   enabled: !isSaving,
                   onSubmitted: (_) => save(),
                   onChanged: (text) {
                     if (!autoTranslate || text.trim().isEmpty) return;
                     debounceTimer?.cancel();
                     debounceTimer = Timer(
                       const Duration(milliseconds: 500),
                       () async {
                         try {
-                          rusController.text = await translateWord(text.trim());
+                          rusController.text =
+                              await translate.translateToRu(text.trim());
                         } catch (_) {
                           // игнорируем ошибку автоперевода
                         }
                       },
                     );
                   },
                 ),
                 TextField(
                   controller: rusController,
                   focusNode: rusFocus,
                   decoration: const InputDecoration(labelText: "Russian"),
                   textInputAction: TextInputAction.done,
                   enabled: !isSaving,
                   onSubmitted: (_) => save(),
                 ),
                 Row(
                   children: [
                     Checkbox(
                       value: autoTranslate,
                       onChanged: isSaving
                           ? null
                           : (v) => innerSetState(() {
                               autoTranslate = v ?? true;
                             }),
                     ),
diff --git a/lib/main.dart b/lib/main.dart
index ae8c4f9fe5928d26b4543c7ede1e40ab8e61c33b..6559d71a4c1ee107754c1f6874fbb127aa57f6fe 100644
--- a/lib/main.dart
+++ b/lib/main.dart
@@ -693,94 +538,93 @@ class _DictionaryScreenState extends State<DictionaryScreen> {
               ],
             ),
             actions: [
               TextButton(
                 onPressed: isSaving ? null : () => Navigator.pop(context),
                 child: const Text("Cancel"),
               ),
               ElevatedButton(
                 onPressed: isSaving ? null : save,
                 child: const Text("Save"),
               ),
             ],
           );
         },
       ),
     );
 
     debounceTimer?.cancel();
   }
 
   Future<void> _deleteWord(int index) async {
     setState(() {
       words.removeAt(index);
       _filterWords();
     });
-    await saveDict(words);
+    await storage.saveWords(words);
   }
 
   @override
   Widget build(BuildContext context) {
     return Scaffold(
       appBar: AppBar(
         toolbarHeight: 90,
         centerTitle: true,
         title: const CodeDictionaryTitle(
           fontSize: 56, // подгони под высоту AppBar
           strokeWidth: 5, // «слегка мультяшно» — не переборщи
           fillColor: Color.fromARGB(
             255,
             231,
             255,
             223,
           ), // можно заменить на тему
           strokeColor: Color(0xCC000000),
           fontFamily: 'CodictionaryCartoon',
           imagePath: 'assets/media/CODY.png',
         ),
       ),
       body: Column(
         children: [
           Expanded(
             child: ReorderableListView.builder(
               itemCount: filteredWords.length,
               onReorder: (oldIndex, newIndex) {
                 setState(() {
                   if (newIndex > oldIndex) newIndex -= 1;
                   final item = filteredWords.removeAt(oldIndex);
                   filteredWords.insert(newIndex, item);
-                  words.clear();
-                  words.addAll(filteredWords);
-                  saveDict(words);
+                  words = List.from(filteredWords);
                 });
+                storage.saveWords(words);
               },
               itemBuilder: (context, i) {
                 final word = filteredWords[i];
                 return ListTile(
-                  key: ValueKey(word),
-                  title: Text(word["eng"] ?? ""),
-                  subtitle: Text(word["rus"] ?? ""),
+                  key: ValueKey(word.id),
+                  title: Text(word.eng),
+                  subtitle: Text(word.rus),
                   trailing: Row(
                     mainAxisSize: MainAxisSize.min,
                     children: [
                       IconButton(
                         icon: const Icon(Icons.remove_red_eye),
                         onPressed: () =>
                             _showWordExplanation(context, words.indexOf(word)),
                       ),
                       IconButton(
                         icon: const Icon(Icons.edit),
                         onPressed: () =>
                             _addOrEditWord(index: words.indexOf(word)),
                       ),
                       IconButton(
                         icon: const Icon(Icons.delete),
                         onPressed: () => _deleteWord(words.indexOf(word)),
                       ),
                     ],
                   ),
                 );
               },
             ),
           ),
           Padding(
             padding: const EdgeInsets.all(8.0),
